\documentclass{article}
\usepackage[T1, T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{latexsym}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{centernot}
\usepackage{amssymb}
\usepackage{esvect}
\usepackage[a4paper,left=15mm,right=15mm,top=30mm,bottom=20mm]{geometry}
\usepackage{minted}
\parindent=0mm
\parskip=3mm

\newcommand{\pr}[1]{\texttt{#1}}
\def\multiset#1#2{\ensuremath{\left(\kern-.3em\left(\genfrac{}{}{0pt}{}{#1}{#2}\right)\kern-.3em\right)}}
\newcommand{\proven}{\begin{flushright}ч.т.д.\end{flushright}}
\DeclareRobustCommand{\divby}{%
    \mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
  }
\newcommand*{\ndivby}{\centernot\divby}

\lstset { % gang
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
    numbers=left,
}

\title{Темы 1-4. Конструирование Компиляторов, Углубленный Курс}
\author{Валера Мацкевич, 3 курс ПМИ ВШЭ СПб}
\date{на 08.10.2024}

\begin{document}

\maketitle

\begin{enumerate}
    \begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{heap.png}
    \caption{Куча}
    \label{fig:name} 
\end{figure}
    \item[1.] \textit{Примените алгоритм обхода в глубину с разворотом указателей к состоянию памяти представленному на рис. 1 и ответьте на вопросы}:\begin{itemize}
        \item \textit{Какие блоки памяти будут помечены по итогу работы алгоритма?}
        
        Только блоки памяти, начинающиеся с адресов $1, 4, 7, 10, 13, 19$ (всего $6$ блоков), поскольку лишь они достижимы из корней.

        \item \textit{Каково будет состояние кучи и локальных переменных алгоритма в момент, когда будет помечен блок со значением \texttt{\color{blue}7} в первом поле?}
        \begin{itemize}
            \item[(a)] \textit{Необходимо указать значения во всех ячейках памяти в куче или указать ячейки, которые имеют значение, отличное от исходного.}

            Отличные от исходного значения находятся в следующих ячейках памяти: \texttt{[7] = \underline{10}}, \texttt{[11] = \underline{19}}, \texttt{[21] = \underline{1}}, \texttt{[3] = \underline{4}}, \texttt{[5] = \underline{13}}, \texttt{[14] = nil}.
            
            \item[(b)] \textit{Необходимо указать значения в массиве \texttt{done}.}

            В массиве \texttt{done} нули находятся на всех позициях кроме блоков памяти, начинающихся со следующих позиций: \texttt{done[13] = 1}, \texttt{done[4] = 1}, \texttt{done[1] = 2}, \texttt{done[19] = 2}, \texttt{done[10] = 1}.
            
            \item[(c)] \textit{Необходимо указать значения переменных \texttt{t, x, y}.}
        
            Значения будут следующие: \texttt{t = \textbf{\underline{10}}}, \texttt{x = \textbf{\color{blue} 7}}, \texttt{y = \textbf{\color{blue} 7}}
        \end{itemize}

        \item \textit{Сколько операций записи (изменения) памяти в куче и массиве \texttt{done} требуется для алгоритма на данном примере?}

        На каждый спуск вниз по дереву поиска в глубину производится $2$ записи в память: одну на разворот указателя, одну на его восстановление, а спусков всего $5$, поэтому будет $10$ записей в память. \\ Для массива \texttt{done} всё проще: поскольку мы знаем, что будет затронуто $6$ блоков, а для покраски блока полностью требуется \texttt{BLOCK\_SIZE + 1} записей, то в него будет произведено $24$ записи.

        \item \textit{Какова амортизированная стоимость сборки мусора (в терминах операции записи/изменения памяти в куче и массиве \texttt{done}) на данном примере?}

        \textbf{Ответ}: $\frac{10 + 24}{H - R} = \frac{34}{3} = 11$ записей.

    \end{itemize}

    \item[2.] \textit{Примените алгоритм сборки мусора копированием с гибридным перенаправлением указателей, к состоянию памяти представленному на рис. 1 и ответьте на вопросы ниже. В контексте сборки копированием, раздел from-space включает адреса с 1 до 30 (включительно), а раздел to-space — адреса с 31 до 60 (включительно).}
    \begin{itemize}
        \item \textit{Каково состояние кучи после работы алгоритма?}

        Корни:
        \begin{center}
        \begin{tabular}{ |c|c|c|c| } 
         \hline
         {\color{blue}3} & \underline{31} & {\color{blue}2} & {\color{blue}9} \\ 
         \hline
        \end{tabular}
        \end{center}
        Память (x значит, что значения не отличаются):
        \begin{center}
        \scalebox{0.75}{
        \begin{tabular}{ ||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|| } 
         \hline
         1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 & 22 & 23 & 24 & 25 & 26 & 27 & 28 & 29 & 30\\ 
         \hline
         \underline{37} & x & x & \underline{46} & x & x & x & \underline{34} & x & x & \underline{43} & x & x & \underline{31} & x & x & x & x & x & \underline{40} & x & x & x & x & x & x & x & x & x & x \\
         \hline
        \end{tabular}}
        \end{center}
        \begin{center}
        \scalebox{0.7}{
        \begin{tabular}{ ||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|| } 
         \hline
         31 & 32 & 33 & 34 & 35 & 36 & 37 & 38 & 39 & 40 & 41 & 42 & 43 & 44 & 45 & 46 & 47 & 48 & 49 & 50 & 51 & 52 & 53 & 54 & 55 & 56 & 57 & 58 & 59 & 60\\ 
         \hline
          {\color{blue}{9}} & \underline{46} & \underline{34} & {\color{blue}7} & \texttt{nil} & \underline{37} & {\color{blue}5} & \texttt{nil} & \underline{40} & {\color{blue}4} & \underline{31} & \underline{43} & {\color{blue}8} & \underline{34} & \texttt{nil} & {\color{blue}1} & \underline{37} & \texttt{nil} & x & x & x & x & x & x & x & x & x & x & x & x\\ 
         \hline
        \end{tabular}}
        \end{center}

        \item \textit{Какой адрес в to-space соответсвует адресу 4 из from-space?}

        \textbf{Ответ}: \underline{46}.

        \item \textit{Каково состояние кучи в момент вызова процедуры \texttt{Forward(p4)}, где \texttt{p4} — адрес копии данных, которые находились по адресу 4 до сборки?}

        В предположении, что в условии задачи имелся ввиду вызов \texttt{Forward(4)}, состояние кучи такое же, как и в пункте "после работы алгоритма", за исключением: \texttt{[4] = x}, \texttt{[32] = x}, \texttt{[46] = x}, \texttt{[47] = x}, \texttt{[48] = x}.

        \item \textit{Сколько операций записи (изменения) памяти в куче требуется для алгоритма на данном примере? Считайте, что копирование каждого машинного слова стоит 1 единицу.}

        \textbf{Ответ}: $18$ копирований и $6$ записей, итого $24$ единицы.

        \item \textit{Какова амортизированная стоимость сборки мусора (в терминах операции записи/изменения памяти в куче) на данном примере?}

        \textbf{Ответ}: $\frac{24}{H - R} = 8$ записей.
    \end{itemize}

    \item[3.] \textit{Аргументированно ответьте на вопросы связанные с работой следующей программы:}

    \begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{code.png}
    \caption{Программа с циклом}
    \label{fig:name}
    \end{figure}

    \begin{itemize}
        \item \textit{Каково общее количество памяти (кол-во машинных слов), которое выделяет эта программа на куче на протяжении своей работы?}
    
        $7$ раз будет создана переменная \texttt{n}, по $6$ раз во внешнем цикле в функции \texttt{r} будут вызов \texttt{append} (в хвостовом вызове которого всегда есть аллокация $2$-ух слов) и аллокация \texttt{i}, также внутренний цикл содержит $0 + 1 + 2 + 3 + 4 + 5 = 15$ аллокаций переменной \texttt{j} и \texttt{i}, итого -- $7 + 3\cdot6 + 2\cdot15= 55$ машинных слов.

        \textbf{Ответ}: $55$ машинных слов.

        \item \textit{Какое максимальное количество живой памяти (достижимых машинных слов) находится на куче в течение работы этой программы?}

        Максимум одновременно могут жить слово \texttt{j}, слово \texttt{i}, слово \texttt{n}, и $2 \cdot 6$ слов \texttt{a}, итого $3 + 2\cdot 6 = 15$ машинных слов.

        \textbf{Ответ}: $15$ машинных слов.

        \item \textit{При использовании копирующего сборщика мусора без поколений, достаточно ли будет $20$ машинных слов на from-space (и столько же на to-space)? Достаточно ли $15$ машинных слов? $30$ машинных слов?}

        $20$ слов достаточно, если запускать наш stop-the-world копирующий сборщих мусора после каждой аллокации, переполняющей from-space. $30$ слов хватит с запасом. $15$ слов -- нет, поскольку при пиковом потреблении памяти, увеличение любого из счётчиков создаёт новый "временный" объект, который некуда положить.

        \item \textit{При использовании сборки по поколениям (на основе копирующего сборщика мусора) с двумя поколениями ($G_0$ и $G_1$) общим размером в $30$ машинных слов, как бы вы разделили память по поколениям (сколько машинных слов будет относится к $G_0$, а сколько — к $G_1$)?}

        Память которой имеет смысл жить долго для данной программы -- лишь переменные \texttt{n}, и список \texttt{a}, итого получая $1 + 2\cdot6 = 13$ слов на $G_1$.
    \end{itemize}

    \item[4.] \textit{Продемонстрируйте работу алгоритма Бейкера (инкрементальная сборка мусора), полагаясь на гибридный (semi-depth-first) алгоритм обхода и перенаправления указателей, на следующей программе. Учтите, что общая доступная память (from-space + to-space) -- $60$ машинных слов.}

    \begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{kalllket.png}
    \caption{Программа с Фибоначчи}
    \label{fig:name}
    \end{figure}

    \textbf{\textit{Примечание:}} мне всегда казалось, что алгоритм Бейкера не имеет как такового разделения на from-space и to-space, что он на самом деле treadmill алгоритм с раскраской в три цвета. Судя по вопросам в этом задании -- я не прав, поэтому это задание я решал на интуицию\ldots

    \begin{itemize}
        \item \textit{В какой момент работы программы происходит инициализация сборки мусора? Происходит ли инициализация второй раз? Если да, то в какой момент?}

        Вычисление \texttt{fib(5)} генерирует $3 \cdot 9 = 27$ машинных слов. После, при вычислении \texttt{fib(3)}, во время аллокации \texttt{fib(1)} на строчке $3$, память в from-space заканчивается, \textbf{отчего впервые происходит инициализация сборщика мусора}.

        Во второй раз инициализация не произойдёт, потому что всего памяти выделяется недостаточно: каждая аллокация очищает по одному элементу (по крайней мере, пока не дойдёт до \texttt{fib(5).left.left}).

        \item \textit{Сколько мусора (кол-во машинных слов) находится на куче в момент вызова сборщика мусора (первый раз)?}

        $0$, мусора не появится вплоть до конца жизни \texttt{fib(3)} на $14$-й строчке.

        \item \textit{Сколько мусора (кол-во машинных слов) находится на куче в момент завершения сборки мусора (первый раз)?}

        Мы очистим всё, кроме \texttt{fib(3)} с $14$-й строчки. То есть $3\cdot3 = 9$ машинных слов. 

        \item \textit{Каково состояние кучи после выполнения строчки 16 в основной программе?} \begin{itemize}
            \item[(a)] \textit{Покажите состояние ячеек памяти в from-space и to-space.}

            \item[(b)] \textit{Покажите значения (куда указывают) переменные \texttt{scan}, \texttt{next}, \texttt{limit}.}
        \end{itemize}
        
    \end{itemize}
    
\end{enumerate}

\end{document}
